### 执行环境及作用域
执行环境定义了函数或者变量有权访问的其他数据,决定了他们各自的行为.
每个执行环境都有一个与之关联的变量对象,环境中定义的所有变量和函数都保存在这个对象中.
每个函数都有自己的执行环境,当执行流进入一个函数时,函数的的环境就会被推入一个执行环境栈中,
执行完毕后,栈将其环境推出,把控制权交给之前的执行环境.

当代码在一个环境中执行时,会创建变量对象的一个作用域链.
作用域链的用途,是保证对执行环境有权访问的变量和函数的有序访问.

当代码在一个环境中运行时,会创建变量对象的一个作用域链.作用域链的用途是保证对执行环境有权访问的所有变量和函数的有序访问.
作用域链的前端,始终都是当前执行代码所在环境的变量对象.如果这个环境是函数,则将其活动对象作为变量对象.
作用域链中的下一个变量对象来自包含环境,最终到全局对象window.
延长作用域链 
try catch  和 with语句.

### 垃圾回收
 1. 标记清除  (比较常用)
 垃圾收集器在运行的时候会给存储在内存中的所有变量都加上标记,然后,他会去掉环境中的变量以及被环境中变量引用的变量的标记.
 而在此之后有标记的变量将被视为准备删除的变量.

 2. 引用计数.
跟踪记录每个值被引用的次数 ,通过引用来适当增加他的引用次数,当引用计数为0时,表明该变量可以被清除.
 
### typeof 操作符
undefiend/变量未定义 boolean/布尔值  string/字符串 number/数值 object对象或者null function/函数 symbol/Symbol
### 相等(==)规则
1. 如果有一个操作数为布尔值,则先转为数值(false 0  true 1);
2. 如果一个操作数为字符串,另一个为数值,将字符串转换为数值
3. 如果一个操作数为对象,另一个不是,调用对象的valurOf方法,用得到的原始值调用之前的规则比较;

[注意]:
1. nullhe undefiend是相等的;
2. 比较之前,不能见null和undefined转换为其他任何值;
3. 如果有一个操作数为NaN,返回false,即便两个NaN比较也是false
4. 如果两个都是对象,比较是不是同一个对象,如果两个操作数指向同一个对象,返回true.
### 全等(===)规则
全等比较前不会转换操作数,其他情况一样.
### 